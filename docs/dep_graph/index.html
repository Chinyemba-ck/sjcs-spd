<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Project Dependency Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        #controls label {
            display: block;
            margin: 5px 0;
            font-size: 14px;
        }
        
        #controls input[type="checkbox"] {
            margin-right: 5px;
        }
        
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .node {
            cursor: move;
        }
        
        .node rect {
            stroke-width: 2px;
            transition: all 0.3s ease;
        }
        
        .node:hover rect {
            filter: brightness(1.2);
        }
        
        .node.highlighted rect {
            stroke-width: 4px;
            stroke: #fff !important;
            filter: brightness(1.4);
        }
        
        .node.dimmed rect {
            opacity: 0.3;
        }
        
        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 12px;
            fill: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .link {
            fill: none;
            stroke-width: 1.5px;
            opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        .link-import {
            stroke: #4fc3f7;
        }
        
        .link-hierarchy {
            stroke: #81c784;
            stroke-dasharray: 5, 5;
        }
        
        .link.highlighted {
            opacity: 1;
            stroke-width: 3px;
        }
        
        .link.highlighted-incoming {
            stroke: #ff6b6b !important;
        }
        
        .link.highlighted-outgoing {
            stroke: #4ecdc4 !important;
        }
        
        .link.dimmed {
            opacity: 0.1;
        }
        
        /* Arrow markers */
        .arrow-import {
            fill: #4fc3f7;
        }
        
        .arrow-hierarchy {
            fill: #81c784;
        }
        
        .arrow-highlighted-incoming {
            fill: #ff6b6b;
        }
        
        .arrow-highlighted-outgoing {
            fill: #4ecdc4;
        }
        
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
        }
        
        .legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 10px;
            position: relative;
        }
        
        .legend-arrow {
            position: absolute;
            right: 0;
            top: -3px;
            width: 0;
            height: 0;
            border-left: 8px solid;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
        }
        
        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 5px 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>Controls</h3>
            <label>
                <input type="checkbox" id="showImports" checked> Show Import Links
            </label>
            <label>
                <input type="checkbox" id="showHierarchy" checked> Show Hierarchy Links
            </label>
            <label>
                <input type="checkbox" id="showLabels" checked> Show Labels
            </label>
            <label>
                <input type="checkbox" id="showArrows" checked> Show Arrow Directions
            </label>
        </div>
        
        <div id="status">Loading import_graph.json...</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-line" style="background: #4fc3f7;">
                    <div class="legend-arrow" style="border-left-color: #4fc3f7;"></div>
                </div>
                Import dependency (A → B means A imports B)
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #81c784; background-image: repeating-linear-gradient(90deg, transparent, transparent 5px, #1a1a1a 5px, #1a1a1a 10px);">
                    <div class="legend-arrow" style="border-left-color: #81c784;"></div>
                </div>
                File hierarchy (parent → child)
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #ff6b6b;"></div>
                Incoming imports (imports this file)
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #4ecdc4;"></div>
                Outgoing imports (this file imports)
            </div>
        </div>
    </div>
    
    <div class="tooltip"></div>

    <script>
        let width = window.innerWidth;
        let height = window.innerHeight;
        let currentData = null;
        let simulation = null;
        let svg = null;
        let g = null;
        let styleConfig = null;
        
        // State
        let showImports = true;
        let showHierarchy = true;
        let showLabels = true;
        let showArrows = true;

        // Default color scheme
        const defaultColors = [
            '#e91e63', '#2196f3', '#4caf50', '#ff9800', '#9c27b0',
            '#00bcd4', '#f44336', '#ffeb3b', '#795548', '#607d8b'
        ];

        async function loadData() {
            try {
                // Load import graph
                const graphResponse = await fetch('import_graph.json');
                if (!graphResponse.ok) {
                    throw new Error('Failed to load import_graph.json');
                }
                const graphData = await graphResponse.json();
                
                // Try to load style config
                try {
                    const styleResponse = await fetch('graph_style.json');
                    if (styleResponse.ok) {
                        styleConfig = await styleResponse.json();
                        document.getElementById('status').textContent = 'Loaded with custom styling';
                    }
                } catch (e) {
                    // Style config is optional
                    document.getElementById('status').textContent = 'Loaded with default styling';
                }
                
                createVisualization(graphData);
            } catch (error) {
                document.getElementById('status').innerHTML = `<span class="error">Error: ${error.message}</span>`;
                console.error('Error loading data:', error);
            }
        }

        function getNodeColor(node) {
            // Check custom style rules first
            if (styleConfig && styleConfig.nodeColors) {
                for (const rule of styleConfig.nodeColors) {
                    const regex = new RegExp(rule.pattern);
                    if (regex.test(node.fullPath)) {
                        return rule.color;
                    }
                }
            }
            
            // Default coloring based on path depth and hash
            const parts = node.fullPath.split('/');
            const isInit = node.name.includes('__init__');
            const isTest = node.fullPath.includes('test');
            
            if (isInit) return '#666';
            if (isTest) return '#ff9800';
            
            // Use consistent color based on top-level directory
            const topLevel = parts[0] || 'root';
            let hash = 0;
            for (let i = 0; i < topLevel.length; i++) {
                hash = topLevel.charCodeAt(i) + ((hash << 5) - hash);
            }
            return defaultColors[Math.abs(hash) % defaultColors.length];
        }

        function processData(data) {
            const nodes = [];
            const links = [];
            const nodeMap = {};
            
            // Create nodes
            Object.keys(data).forEach((file, index) => {
                const parts = file.split('/');
                const name = parts[parts.length - 1];
                const depth = parts.length - 1;
                
                const node = {
                    id: file,
                    name: name,
                    fullPath: file,
                    depth: depth,
                    imports: data[file] || [],
                    importedBy: [],
                    group: parts[0] || 'root'
                };
                
                nodes.push(node);
                nodeMap[file] = node;
            });
            
            // Create import links and track reverse dependencies
            Object.keys(data).forEach(file => {
                (data[file] || []).forEach(importedFile => {
                    if (nodeMap[importedFile]) {
                        links.push({
                            source: file,
                            target: importedFile,
                            type: 'import'
                        });
                        nodeMap[importedFile].importedBy.push(file);
                    }
                });
            });
            
            // Create hierarchy links
            Object.keys(data).forEach(file => {
                const parts = file.split('/');
                if (parts.length > 1) {
                    const parentParts = parts.slice(0, -1);
                    
                    // Look for __init__.py in parent directory
                    const parentInit = parentParts.join('/') + '/__init__.py';
                    if (nodeMap[parentInit]) {
                        links.push({
                            source: parentInit,
                            target: file,
                            type: 'hierarchy'
                        });
                    } else {
                        // If no __init__.py, connect to nearest parent
                        for (let i = parentParts.length - 1; i >= 0; i--) {
                            const possibleParent = parentParts.slice(0, i + 1).join('/') + '/__init__.py';
                            if (nodeMap[possibleParent]) {
                                links.push({
                                    source: possibleParent,
                                    target: file,
                                    type: 'hierarchy'
                                });
                                break;
                            }
                        }
                    }
                }
            });
            
            return { nodes, links };
        }

        function createVisualization(data) {
            // Clear existing
            d3.select('#container svg').remove();
            
            const { nodes, links } = processData(data);
            currentData = { nodes, links };
            
            // Create SVG
            svg = d3.select('#container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Define arrow markers
            const defs = svg.append('defs');
            
            // Arrow markers for different states
            const arrowTypes = [
                { id: 'arrow-import', class: 'arrow-import' },
                { id: 'arrow-hierarchy', class: 'arrow-hierarchy' },
                { id: 'arrow-highlighted-incoming', class: 'arrow-highlighted-incoming' },
                { id: 'arrow-highlighted-outgoing', class: 'arrow-highlighted-outgoing' }
            ];
            
            arrowTypes.forEach(arrow => {
                defs.append('marker')
                    .attr('id', arrow.id)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 15)
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('class', arrow.class);
            });
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            g = svg.append('g');
            
            // Create tooltip
            const tooltip = d3.select('.tooltip');
            
            // Create force simulation
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(120))
                .force('charge', d3.forceManyBody().strength(-400))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(60));
            
            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', d => `link link-${d.type}`)
                .attr('marker-end', d => showArrows ? `url(#arrow-${d.type})` : null)
                .style('display', d => {
                    if (d.type === 'import' && !showImports) return 'none';
                    if (d.type === 'hierarchy' && !showHierarchy) return 'none';
                    return 'block';
                });
            
            // Create nodes
            const node = g.append('g')
                .selectAll('.node')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add rectangles for nodes
            node.append('rect')
                .attr('width', d => Math.max(d.name.length * 7, 80))
                .attr('height', 30)
                .attr('x', d => -Math.max(d.name.length * 7, 80) / 2)
                .attr('y', -15)
                .attr('rx', 5)
                .attr('fill', d => getNodeColor(d))
                .attr('stroke', '#333');
            
            // Add labels
            node.append('text')
                .text(d => d.name)
                .style('display', showLabels ? 'block' : 'none');
            
            // Add hover effects
            node.on('mouseover', function(event, d) {
                // Highlight connected nodes and edges
                const connectedNodes = new Set([d.id]);
                const incomingLinks = [];
                const outgoingLinks = [];
                
                links.forEach(link => {
                    if (link.source.id === d.id) {
                        connectedNodes.add(link.target.id);
                        outgoingLinks.push(link);
                    } else if (link.target.id === d.id) {
                        connectedNodes.add(link.source.id);
                        incomingLinks.push(link);
                    }
                });
                
                // Update node styling
                node.classed('highlighted', n => n.id === d.id)
                    .classed('dimmed', n => !connectedNodes.has(n.id));
                
                // Update link styling
                link.classed('highlighted', l => l.source.id === d.id || l.target.id === d.id)
                    .classed('highlighted-incoming', l => l.target.id === d.id && l.type === 'import')
                    .classed('highlighted-outgoing', l => l.source.id === d.id && l.type === 'import')
                    .classed('dimmed', l => l.source.id !== d.id && l.target.id !== d.id)
                    .attr('marker-end', l => {
                        if (!showArrows) return null;
                        if (l.target.id === d.id && l.type === 'import') return 'url(#arrow-highlighted-incoming)';
                        if (l.source.id === d.id && l.type === 'import') return 'url(#arrow-highlighted-outgoing)';
                        return `url(#arrow-${l.type})`;
                    });
                
                // Show tooltip
                tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                tooltip.html(`
                    <strong>${d.fullPath}</strong><br/>
                    <hr style="margin: 5px 0; border-color: #444;">
                    Imports: ${d.imports.length} files<br/>
                    Imported by: ${d.importedBy.length} files<br/>
                    Depth: ${d.depth}
                `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            })
            .on('mouseout', function(d) {
                // Reset styling
                node.classed('highlighted', false)
                    .classed('dimmed', false);
                link.classed('highlighted', false)
                    .classed('highlighted-incoming', false)
                    .classed('highlighted-outgoing', false)
                    .classed('dimmed', false)
                    .attr('marker-end', l => showArrows ? `url(#arrow-${l.type})` : null);
                
                tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            });
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Event handlers
        document.getElementById('showImports').addEventListener('change', (e) => {
            showImports = e.target.checked;
            d3.selectAll('.link-import').style('display', showImports ? 'block' : 'none');
        });

        document.getElementById('showHierarchy').addEventListener('change', (e) => {
            showHierarchy = e.target.checked;
            d3.selectAll('.link-hierarchy').style('display', showHierarchy ? 'block' : 'none');
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            showLabels = e.target.checked;
            d3.selectAll('.node text').style('display', showLabels ? 'block' : 'none');
        });

        document.getElementById('showArrows').addEventListener('change', (e) => {
            showArrows = e.target.checked;
            d3.selectAll('.link').attr('marker-end', function() {
                if (!showArrows) return null;
                const linkType = d3.select(this).classed('link-import') ? 'import' : 'hierarchy';
                return `url(#arrow-${linkType})`;
            });
        });

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            if (svg) {
                svg.attr('width', width).attr('height', height);
                if (simulation) {
                    simulation.force('center', d3.forceCenter(width / 2, height / 2));
                    simulation.alpha(0.3).restart();
                }
            }
        });

        // Load data on startup
        loadData();
    </script>
</body>
</html>